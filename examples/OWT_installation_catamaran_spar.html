<html>

<head>
	<title>OWT Installation</title>
	<script src="../build/vessel.js"></script>
	<script src="../source/math/interpolation.js"></script>

	<script src="3D_engine/three_r118.js"></script>
	<script src="3D_engine/GLTFLoader.js"></script>

	<script src="3D_engine/Ship3D_v2.js"></script>

	<!-- Upgrading to WaterShader2.js will remove the dependency
	on Mirror.js as well as open up possibilities for visualizing approximate water flows around vessels. -->
	<!-- <script src="libs/Mirror.js"></script>-->
	<!-- <script src="libs/WaterShader.js"></script> -->
	<script src="3D_engine/Water.js"></script>

	<script src="3D_engine/legacy/OrbitControls.js"></script>
	<script src="3D_engine/dat.gui.min.js"></script>
	<script src="3D_engine/skybox_from_examples_r118.js"></script>
	<script src="libs/browse_files_Elias_Hasle.js"></script>

	<script src="3D_engine/Patch_interpolation.js"></script>
	<script src="./libs/d3.v3.min.js"></script>
	<script src="3D_engine/renderRayCaster.js"></script>
	<!--<script src="Moving_bodies_Elias_Hasle.js"></script>-->
	<script src="3D_engine/Playback.js"></script>
	<!-- <script src="snippets/Configurable_ocean.js"></script> -->
	<script src="3D_engine/Configurable_ocean_v2.js"></script>
	<script src="libs/zingchart.min.js"></script>
	<!--<script src="keyboard_arrow_input_Elias_Hasle.js"></script>-->
</head>

<style>
	table {
		margin-top: 15px;
		margin-bottom: 10px;
	}

	table,
	td {
		color: #000;
		border: 1px solid #fff;
	}

	td {
		padding-right: 10px;
	}

	tr:nth-child(even) {
		background-color: #cccccc;
	}

	tr:nth-child(odd) {
		background-color: #fff;
	}

	#button {
		position: fixed;
		bottom: 16px;
		right: 16px;

		padding: 12px;
		border-radius: 50%;
		margin-bottom: 0px;

		background-color: #fff;
		opacity: 0.9;
		z-index: 999;

		box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);
	}

	/* ******* Signature template ******* */

	#info {
		position: absolute;
		color: #011C40;
		bottom: 20px;
		right: 5px;
		font-size: 12px;
		width: 100%;
		padding: 10px;
		box-sizing: border-box;
		text-align: right;
		-moz-user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
		user-select: none;
		pointer-events: none;
		z-index: 1;
	}

	#info a {
		color: #A60D0D;
		pointer-events: auto;
	}

	/* ******* ******* ******* */

	#tooltip {
		/* visibility: hidden; */
		position: absolute;
		font-family: Helvetica;
		display: block;
		background-color: black;
		color: #fff;
		text-align: center;
		padding: 5px 10px;
		border-radius: 6px;
		z-index: 101;
	}

	.close {
		position: absolute;
		right: 10px;
		top: 5px;
		width: 16px;
		height: 22px;
		opacity: 0.6;
	}

	.close:hover {
		opacity: 1;
		cursor: pointer;
	}

	.close:before,
	.close:after {
		position: absolute;
		left: 10px;
		content: " ";
		height: 10px;
		width: 2px;
		background-color: #fff;
	}

	.close:before {
		transform: rotate(45deg);
	}

	.close:after {
		transform: rotate(-45deg);
	}

	/* LOADER */
	#loader-wrapper {
		width: 100%;
		height: 100%;
		text-align: center;
		position: absolute;
		top: 0;
		left: 0;
		background-color: #fff;
		color: #000000;
		font-family: Helvetica;
		z-index: 105;
	}

	.loader {
		display: inline-block;
		width: 50px;
		height: 50px;
		position: relative;
		margin-top: 17%;
		border-radius: 50%;
		vertical-align: middle;
	}

	.loader,
	.loader:before,
	.loader:after {
		animation: 1s infinite ease-in-out;
	}

	.loader:before,
	.loader:after {
		width: 100%;
		height: 100%;
		border-radius: 50%;
		position: absolute;
		top: 0;
		left: 0;
	}

	.loader-white {
		background-color: #fff;
	}

	.loader-1 {
		animation-name: loader1;
	}

	@-webkit-keyframes loader1 {
		from {
			transform: scale(0);
			opacity: 1;
		}

		to {
			transform: scale(1);
			opacity: 0;
		}
	}
</style>

<body>
	<!-- <div id="tooltip"></div> -->

	<div id="info">
		<b>Hydrodynamic Analysis for FOWT Installation</b>
		<br><b>(Head Sea, Hs = 2m, Tp = 11s)</b>
		<br>
		Visualization: <a href="https://shiptodata.com/" target="_blank" rel="noopener">Felipe Ferrari</a>
		<br>
		Simulation: Sunghun Hong
		<br>
		CAD Models: Thiago Gabriel Monteiro
		<br>
		Supervision: <a href=" https://www.ntnu.edu/employees/karl.h.halse" target="_blank" rel="noopener">Karl Henning Halse</a><br> and <a href="https://www.ntnu.edu/employees/henrique.gaspar" target="_blank" rel="noopener">Henrique M. Gaspar</a>
		<br>
		<a class="navbar-brand" href="http://www.shiplab.hials.org/"><img src="../images/barquinho.png"
			alt="Shiplab logo" style="height:25px">
		</a>
		&nbsp; &nbsp;
		<a class="navbar-brand" href="https://www.ntnu.no/"><img src="../images/ntnu_logo_black.png"
			alt="NTNU logo" style="height:20px">
		</a>
	</div>

	<div id="loader-wrapper">
		<div class="loader loader-white loader-1"></div>
		<div>
			<h1 style="font-style: italic">Loading...</h1>
		</div>
	</div>

	<!-- <a id="button" target="_blank" href="https://github.com/shiplab/vesseljs/blob/master/examples/OWT_installation.html"
		title="View source code on GitHub" style="">
		<img src="..\images\code-24px.svg" />
	</a> -->
	<div id="plotBottom" style="position:fixed; bottom:0%; float:left; width:100%; height:100%"></div>

	<script>
		"use strict";

		// JavaScript for adding loader page
		window.addEventListener("load", function () {
			var fadeTarget = document.getElementById("loader-wrapper");
			var fadeEffect = setInterval(function () {
				if (!fadeTarget.style.opacity) {
					fadeTarget.style.opacity = 1;
				}
				if (fadeTarget.style.opacity > 0) {
					fadeTarget.style.opacity -= 0.05;
				} else {
					clearInterval(fadeEffect);
					fadeTarget.remove();
				}
			}, 50);
		});

		//Globals
		var renderer, camera, controls, gui, stats;
		var scene, zUpCont, playback, bodies, ocean, shipGLTF, pivot_ship, pivot_buoy;
		var scale, modelStyle;

		// Import global variables for the csv interaction
		var calculated_data, initial_time, max_time, initial_time, data_step_index, delta_time;
		initial_time = 100; // seconds
		data_step_index = 0; // Initial value
		delta_time = 0.5; // seconds

		// // Global variables for raycaster control
		// var intersected;
		// var tooltipElement = document.getElementById("tooltip");

		// // Marker which ensure the table is being displayed
		// tooltipElement.displayingPropTable = false;

		(function main() {
			//Renderer setup
			//document.body.style = "overflow: hidden;";
			document.body.style.overflow = "hidden";
			var container = document.createElement("div");
			container.id = "SimulationWindow";
			// container.style = "position: absolute; top: 0px; height: 75%; right: 320px; width: 50%"
			Object.assign(container.style, {
				position: "absolute",
				top: 0,
				height: "70%",
				width: "75%",
				// right: "320px",
				left: "25%",
			});
			document.body.appendChild(container);
			renderer = new THREE.WebGLRenderer({ antialias: true });
			//renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0xa9cce3);
			container.appendChild(renderer.domElement);

			
			playback = new Playback({ parentGUI: gui });
			// //GUI setup (comment out to remove gui)
			gui = new dat.GUI();
			scale = [];
			

			//Scene setup:
			scene = new THREE.Scene();
			let sun = new THREE.DirectionalLight(0xffffff, 2);
			sun.position.set(- 512, 246, 128);
			scene.add(sun);

			//Ocean size
			let oSize = 2048;

			//Use Z up from now on:
			THREE.Object3D.DefaultUp.set(0, 0, 1);
			zUpCont = new THREE.Group();
			// This rotation must be deleted in order to garantee the real coordinate
			// zUpCont.rotation.x = -0.5 * Math.PI;
			scene.add(zUpCont);

			var skybox = new Skybox(5 * oSize);
			skybox.name = "Skybox";
			scene.add(skybox);

			//Camera setup
			camera = new THREE.PerspectiveCamera(26, window.innerWidth / window.innerHeight, 1, 1000000);

			let onResize = function () {
				let w = container.clientWidth;
				let h = container.clientHeight;
				renderer.setSize(w, h);
				camera.aspect = w / h;
				camera.updateProjectionMatrix();
			};

			camera.up.set(0, 1, 0);

			window.addEventListener("resize", onResize, false);
			onResize();
			camera.position.set(450, 400, -500);
			camera.lookAt(zUpCont.position);
			// zUpCont.add(camera)
			// scene.add(camera)

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			//controls.minDistance = 0;
			// controls.maxDistance = 1.25 * oSize;
			// controls.enablePan = false;
			// controls.maxPolarAngle = 0.5 * Math.PI - 0.1;
			// controls.minPolarAngle = 0.1;

			// zUpCont.add(new THREE.AxesHelper(1000))
			zUpCont.add(new THREE.HemisphereLight(0xccccff, 0x666688, 1));

			ocean = new Ocean({
				// parentGUI: gui,
				sunDir: sun.position.clone().normalize(),
				size: oSize,
				segments: 127
			});

			// playback.add(ocean)
			ocean.name = "Ocean";
			scene.add(ocean);
			scene.rotation.x = - Math.PI / 2;

			// scene.rotation.x = Math.PI;
			// scene.add(new THREE.AxesHelper(500));

			// import binary glTF file
			var boatPath_arr = [
				"3D_models/GLTF/Catamaran_lifiting_structure__stern_concept.glb",
				// "3D_models/GLTF/catamaran_deeper_cutout.glb",
				// "3D_models/GLTF/catamaran_side_concept_04_2023.glb"
			];

			let loaderGLTF = new THREE.GLTFLoader();

			boatPath_arr.map((path, index) => {
				let path_arr = path.split("/");

				let name = path_arr[path_arr.length - 1].split(".")[0];
				const xpos = 63;
				loaderGLTF.load(path, async gltf => {
					shipGLTF = gltf.scene;
					shipGLTF.rotation.x = Math.PI / 2;
					shipGLTF.rotation.y = - Math.PI / 2;
					shipGLTF.position.set(0, xpos, 0);
					shipGLTF.name = name;

					if (shipGLTF.material) {
						shipGLTF.material.side = THREE.DoubleSide;
					}

					// Adding the pivot_ship
					pivot_ship = new THREE.Object3D();
					pivot_ship.position.set(0, 0, 0);
					pivot_ship.add(shipGLTF);

					await zUpCont.add(pivot_ship);

					// Adding the Gui interaction
					// let index_scale = scale.push(gui.addFolder("Ship: " + name)) - 1;
					// scale[index_scale].add(zUpCont.getObjectByName(name).position, "x", -400 + xpos, 400 + xpos, 1);
					// scale[index_scale].add(zUpCont.getObjectByName(name).position, "y", -400 + xpos, 400 + xpos, 1);
					// scale[index_scale].add(zUpCont.getObjectByName(name).rotation, "y", -Math.PI, Math.PI, Math.PI/180).name("Rotation Z");
					// scale[index_scale].add(zUpCont.getObjectByName(name).scale, "x", 0.1, 10, 0.1).name("Scale X");
					// scale[index_scale].add(zUpCont.getObjectByName(name).scale, "y", 0.1, 10, 0.1).name("Scale Y");
					// scale[index_scale].add(zUpCont.getObjectByName(name).scale, "z", 0.1, 10, 0.1).name("Scale Z");
					// scale[index_scale].open();
					// window.dispatchEvent(new Event('resize'));
					document.dispatchEvent(new Event('resize'));
					document.getElementById("plotBottom").style.width = '99%'
					// document.getElementById("plotBottom").style.visibility = 'visible'
				});
			});

			// Adding the spar buoy
			const buoyPath = "3D_models/GLTF/Spar_OWT_Collar.glb";
			loaderGLTF.load(buoyPath, async gltf => {
				let buoyGLTF = gltf.scene;
				buoyGLTF.rotation.x = Math.PI / 2;
				buoyGLTF.rotation.y = - Math.PI / 2;
				buoyGLTF.position.set(-57, 69, 0);

				if (buoyGLTF.material) {
					buoyGLTF.material.side = THREE.DoubleSide;
				}
				
				// Adding the pivot_buoy
				pivot_buoy = new THREE.Object3D();
				pivot_buoy.position.set(0, 0, 0);
				pivot_buoy.add(buoyGLTF);

				await zUpCont.add(pivot_buoy);
			});

			// Recursive function to find element and delete
			function toggleElement(element, name) {
				if (element.children.lenght == 0) {
					return;
				}
				element.children.forEach(child => {
					if (child.group == name) {
						// Verify if it is visible trought the masks layers
						child.layers.mask ? child.layers.disable(0) : child.layers.enable(0);
					}
					toggleElement(child, name);
				});
			}

			modelStyle = {
				model: "ModelGLTF",
				scene: "On",
				displayOutline: true
			};

			scale.push(gui.addFolder("Visualization parameters"));

			scale[0]
				.add(modelStyle, "scene", {
					On: "On",
					Off: "Off"
				})
				.onChange(newValue => {
					switch (newValue) {
						case "On":
							scene.getObjectByName("Skybox").visible = true;
							scene.getObjectByName("Ocean").visible = true;
							break;
						case "Off":
							scene.getObjectByName("Skybox").visible = false;
							scene.getObjectByName("Ocean").visible = false;
							break;
						default:
							break;
					}
				})
				.name("Scenario");
			scale[0].open();

			// scale.push(gui.addFolder("Time parameters"));


			// playback.play()

			// Read the csv results file
			calculated_data = []

			
			// Takes the relevant data in owt_raw_data.csv
			async function readCSV() {
				await d3.csv('./others/ocean_wave_samples/owt_raw_data.csv', function(error, data) {
					if (error) {
						console.error('Error loading CSV file:', error);
					} else {
						// Filter the data to exclude entries without a dot in the specified column
						var columnNames = d3.keys(data[0]);
						var filteredData = columnNames.filter(function(columnName) {
							// Filters out the first column and the columns without a dot
							return !columnName.includes('.') || columnName.includes('.1');
						});
						
						// Filter the data to return only the specified columns
						calculated_data = data.map(d => {
							let obj = {}
							filteredData.forEach(e => {
								obj[e] = parseFloat(d[e])
							})
							return obj
						})
						max_time = calculated_data[calculated_data.length - 2].Time	
						return calculated_data
					}
				});
			}	
			
			// Read the csv results file
			readCSV().then(() => {
				requestAnimationFrame(animate);
			}).catch((error) => {
				console.log("Error reading the csv file");
				console.log(error);
			}).finally();	

			// Set up the graphic animation
			window.feedMotionHeave = function(callback) {
				var tick = {};
				tick.plot0 = pivot_ship.position.z;
				tick.plot1 = pivot_buoy.position.z;				
				callback(JSON.stringify(tick));
			};
			window.feedMotionRoll = function(callback) {
				var tick = {};
				tick.plot0 = pivot_ship.rotation.y * 180 / Math.PI;
				tick.plot1 = pivot_buoy.rotation.y * 180 / Math.PI;
				callback(JSON.stringify(tick));
			};
			window.feedMotionSurge = function(callback) {
				var tick = {};
				tick.plot0 = pivot_ship.position.y;
				tick.plot1 = pivot_buoy.position.y;
				callback(JSON.stringify(tick));
			};
			window.feedMotionSway = function(callback) {
				var tick = {};
				tick.plot0 = pivot_ship.position.x;
				tick.plot1 = pivot_buoy.position.x;
				callback(JSON.stringify(tick));
			};
			window.feedMotionPitch = function(callback) {
				var tick = {};
				tick.plot0 = pivot_ship.rotation.x * 180 / Math.PI;
				tick.plot1 = pivot_buoy.rotation.x * 180 / Math.PI;
				callback(JSON.stringify(tick));
			};
			window.feedMotionYaw = function(callback) {
				var tick = {};
				tick.plot0 = pivot_ship.rotation.z * 180 / Math.PI;
				tick.plot1 = pivot_buoy.rotation.z * 180 / Math.PI;
				callback(JSON.stringify(tick));
			};
			
			// Plot of dashboards
			var dashboard = {
				"graphset": [
					{//---------- ROLL MOTION-----------//
						"type": "line",
						"plotarea": {
							"adjust-layout": true
						},
						"height": "25%",
						"width": "25%",
						"x": "0%",
						"y": "72%",
						"plot": {
							"aspect": "spline",
							"marker": {"visible": false},
						},
						"series": [{
							"values": [0],
							"text": "Cat.[m]"
						}, {
							"values": [0],
							"text": "Buoy[m]"
						}],
						"refresh": {
							"type": "feed",
							"transport": "js",
							"url": "feedMotionRoll()",
							"method": "pull",
							"interval": 500,
							"adjust-scale": true
						},
						scaleY: {
							label: {
								text: 'Roll angle [deg]',
								fontStyle: 'normal',
								fontWeight: 'normal',
							},
						},
						title: {
							text: "Roll motion",
							marginBottom: "0",
							fontFamily: "Helvetica",
							fontWeight: "none",
							fontSize: 12,
							"offset-y": 25,
							"offset-x": 120,
							"width": 100,
							"heigh": 30,
							"background-color": "#333",
							"color": "#FFF",
							"border-radius": "4px"
						},
						plotarea: {
							"margin": "20% 10% 15% dynamic",
						},
						legend: {
							"layout": "float",
							"background-color": "none",
							"border-width": 0,
							"shadow": 0,
							"text-align": "middle",
							"offsetY": 25,
							"align": "center",
							visible: false,
							"item": {
								"font-color": "#black",
								"font-size": "10px"
							}
						},
					},
					{//---------- PITCH MOTION -----------//
						"type": "line",
						"height": "25%",
						"width": "25%",
						"x": "25%",
						"y": "72%",
						"plot": {
							"aspect": "spline",
							"marker": {"visible": false},
						},
						"series": [{
							"values": [0],
							"text": "Cat.[deg]"
						}, {
							"values": [0],
							"text": "Buoy[deg]"
						}],
						"refresh": {
							"type": "feed",
							"transport": "js",
							"url": "feedMotionPitch()",
							"method": "pull",
							"interval": 500,
							"adjust-scale": true
						},
						scaleY: {
							label: {
								text: 'Pitch angle [deg]',
								fontStyle: 'normal',
								fontWeight: 'normal',
							},
						},
						title: {
							text: "Pitch Motion",
							marginBottom: "0",
							fontFamily: "Helvetica",
							fontWeight: "none",
							fontSize: 12,
							"offset-y": 25,
							"offset-x": 120,
							"width": 100,
							"heigh": 30,
							"background-color": "#333",
							"color": "#FFF",
							"border-radius": "4px"
						},
						plotarea: {
							"margin": "20% 5% 15% dynamic",
						},
						legend: {
							"layout": "float",
							"background-color": "none",
							"border-width": 0,
							"shadow": 0,
							"text-align": "middle",
							"offsetY": 25,
							"align": "center",
							visible: false,
							"item": {
								"font-color": "#black",
								"font-size": "10px"
							}
						},
					},
					{//---------- YAW MATION -----------//
						"type": "line",
						"height": "25%",
						"width": "25%",
						"x": "50%",
						"y": "72%",
						"plot": {
							"aspect": "spline",
							"marker": {"visible": false},
						},
						"series": [{
							"values": [0],
							"text": "Cat.[deg]"
						}, {
							"values": [0],
							"text": "Buoy[deg]"
						}],
						"refresh": {
							"type": "feed",
							"transport": "js",
							"url": "feedMotionYaw()",
							"method": "pull",
							"interval": 500,
							"adjust-scale": true
						},
						scaleY: {
							label: {
								text: 'Yaw angle [deg]',
								fontStyle: 'normal',
								fontWeight: 'normal',
							},
						},
						title: {
							text: "Yaw Motion",
							marginBottom: "0",
							fontFamily: "Helvetica",
							fontWeight: "none",
							fontSize: 12,
							"offset-y": 25,
							"offset-x": 120,
							"width": 100,
							"heigh": 30,
							"background-color": "#333",
							"color": "#FFF",
							"border-radius": "4px"
						},
						plotarea: {
							"margin": "20% 0% 15% dynamic",
						},
						legend: {
							"layout": "float",
							"background-color": "none",
							"border-width": 0,
							"shadow": 0,
							"text-align": "middle",
							"offsetY": 25,
							"align": "center",
							visible: false,
							"item": {
								"font-color": "#black",
								"font-size": "10px"
							}
						},
					},
					{//---------- SURGE MOTION -----------//
						"type": "line",
						"height": "25%",
						"width": "25%",
						"x": "0%",
						"y": "0%",
						"plot": {
							"aspect": "spline",
							"marker": {"visible": false},
						},
						"series": [{
							"values": [0],
							"text": "Cat."
						}, {
							"values": [0],
							"text": "Buoy"
						}],
						"refresh": {
							"type": "feed",
							"transport": "js",
							"url": "feedMotionSurge()",
							"method": "pull",
							"interval": 500,
							"adjust-scale": true
						},
						scaleY: {
							label: {
								text: 'Surge translation [m]',
								fontStyle: 'normal',
								fontWeight: 'normal',
							},
						},
						title: {
							text: "Surge Motion",
							marginBottom: "0",
							fontFamily: "Helvetica",
							fontWeight: "none",
							fontSize: 12,
							"offset-y": 10,
							"offset-x": 120,
							"width": 100,
							"heigh": 30,
							"background-color": "#333",
							"color": "#FFF",
							"border-radius": "4px"
						},
						plotarea: {
							"margin": "20% 10% 15% dynamic",
						},
						legend: {
							"layout": "float",
							"background-color": "none",
							"border-width": 0,
							"shadow": 0,
							"text-align": "middle",
							"offsetY": 25,
							"align": "center",
							visible: true,
							"item": {
								"font-color": "#black",
								"font-size": "10px"
							}
						},
					},
					{//---------- SWAY MOTION -----------//
						"type": "line",
						"height": "25%",
						"width": "25%",
						"x": "0%",
						"y": "25%",
						"plot": {
							"aspect": "spline",
							"marker": {"visible": false},
						},
						"series": [{
							"values": [0],
							"text": "Cat.[Sway]"
						}, {
							"values": [0],
							"text": "Buoy[Sway]"
						}],
						"refresh": {
							"type": "feed",
							"transport": "js",
							"url": "feedMotionSway()",
							"method": "pull",
							"interval": 500,
							"adjust-scale": true
						},
						scaleY: {
							label: {
								text: 'Sway translation[m]',
								fontStyle: 'normal',
								fontWeight: 'normal',
							},
						},
						title: {
							text: "Sway Motion",
							marginBottom: "0",
							fontFamily: "Helvetica",
							fontWeight: "none",
							fontSize: 12,
							"offset-y": 25,
							"offset-x": 120,
							"width": 100,
							"heigh": 30,
							"background-color": "#333",
							"color": "#FFF",
							"border-radius": "4px"
						},
						plotarea: {
							"margin": "20% 10% 15% dynamic",
						},
						legend: {
							"layout": "float",
							"background-color": "none",
							"border-width": 0,
							"shadow": 0,
							"text-align": "middle",
							"offsetY": 25,
							"align": "center",
							visible: false,
							"item": {
								"font-color": "#black",
								"font-size": "10px"
							}
						},
					},
					{//---------- HEAVE MOTION -----------//
						"type": "line",
						"height": "25%",
						"width": "25%",
						"x": "0%",
						"y": "50%",
						"plot": {
							"aspect": "spline",

							"marker": {"visible": false},
						},
						"series": [{
							"values": [0],
							"text": "Cat.[m]"
						}, {
							"values": [0],
							"text": "Buoy[Sway]"
						}],
						"refresh": {
							"type": "feed",
							"transport": "js",
							"url": "feedMotionHeave()",
							"method": "pull",
							"interval": 500,
							"adjust-scale": true
						},
						scaleY: {
							label: {
								text: 'Heave translation [m]',
								fontStyle: 'normal',
								fontWeight: 'normal',
							},
						},
						title: {
							text: "Heave Motion",
							marginBottom: "0",
							fontFamily: "Helvetica",
							fontWeight: "none",
							fontSize: 12,
							"offset-y": 25,
							"offset-x": 120,
							"width": 100,
							"heigh": 30,
							"background-color": "#333",
							"color": "#FFF",
							"border-radius": "4px"
						},
						plotarea: {
							"margin": "20% 10% 15% dynamic",
						},
						legend: {
							"layout": "float",
							"background-color": "none",
							"border-width": 0,
							"shadow": 0,
							"text-align": "middle",
							"offsetY": 25,
							"align": "center",
							visible: false,
							"item": {
								"font-color": "#black",
								"font-size": "10px"
							}
						},
					}
				]
			}

			window.onload = function () {
				zingchart.render({
					id: 'plotBottom',
					height: "100%",
					width: "100%",
					// visibility: "hidden",
					data: dashboard,
				});
			};
			
		})();

		var mouse = new THREE.Vector2();

		function onMouseMove(event) {
			// calculate mouse position in normalized device coordinates
			// (-1 to +1) for both components
			mouse.clientX = event.clientX;
			mouse.clientY = event.clientY;

			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
		}

		window.addEventListener("mousemove", onMouseMove, false);

		// Enabling setting Layers
		// scene.layers.enable(1)

		// ToolTip function shows the object name when mouse is on @ferrari212
		function toolTip(tooltip, intersected) {
			if (intersected.status) {
				// Inserting tooltip
				tooltip.style.visibility = "visible";
				tooltip.style.left = mouse.clientX + 20;
				tooltip.style.top = mouse.clientY + 10;
				tooltip.textContent = intersected.name;
				zUpCont.remove(zUpCont.getObjectByName(intersected.name));
			} else {
				// Taking off tool tip
				tooltip.style.visibility = "hidden";
			}
		}

		// Function shows the object information when object is clicked on @ferrari212
		function clickedInformation(tooltipElement, intersected) {
			// tooltipElement is the html div that will contain the info
			// Intersected is the element with the mouse on
			document.body.style.cursor = "pointer";
			var name = intersected.name;
			// Classes for changing the inner displayed table @ferrari
			class ListMarkup {
				constructor() {
					this.innerHTML = `<a onclick="tooltipElement.displayingPropTable = false;" class="close"></a><table>`;
				}
				extendSingleInnerHTML(key, value, unit = "") {
					this.innerHTML += `<tr><td> ${key} </td><td> ${value} ${unit} </td></tr>`;
				}
				arrayExtendInnerHTML(object, fromNumber = 0, toEnd = 0, unit = "") {
					var keys = Object.keys(object);
					for (let i = fromNumber; i < keys.length - toEnd; i++) {
						this.innerHTML += `<tr><td> ${keys[i]} </td><td> ${object[keys[i]]} ${unit} </td></tr>`;
					}
				}
				closeInnerHTML() {
					this.innerHTML += `</table>`;
				}
			}

			// Add the table with the informations
			function addTable(block, element) {
				// Invalidate function in case of element undefined
				if (element === undefined) return;
				var listMarkup = new ListMarkup();
				tooltipElement.displayingPropTable = true;

				if (element.id === undefined) {
					// For structural elements
					var keys = Object.keys(element);
					listMarkup.extendSingleInnerHTML("Group", element.affiliations.group);
					listMarkup.arrayExtendInnerHTML(element, 1);
				} else {
					// For non structural elements
					listMarkup.extendSingleInnerHTML("Id", element.id);
					listMarkup.arrayExtendInnerHTML(element.baseObject.boxDimensions, 0, 0, "m");
					listMarkup.arrayExtendInnerHTML(element.referenceState, 0, 0, "m");
				}
				listMarkup.closeInnerHTML();

				// Inserting tooltip
				block.style.visibility = "visible";
				block.style.left = mouse.clientX + 20;
				block.style.top = mouse.clientY + 10;
				block.innerHTML = listMarkup.innerHTML;
				zUpCont.remove(zUpCont.getObjectByName(element.name));
			}
			document.getElementById("SimulationWindow").onclick = () => addTable(tooltipElement, element);
		}

		function interpolate_csv(data_after, data_before, delta) {
			// Interpolate the data from the csv file
			let data = {
				"Catamaran": {},
				"Spar": {},
			}
			
			// Loop through each key
			for (const key in data_after){
				let new_key = key.split(".")[0]
				if (key.includes(".1")) {
					data["Spar"][new_key] = lerp(data_after[key], data_before[key], delta)
				} else {
					data["Catamaran"][new_key] = lerp(data_after[key], data_before[key], delta)
				}
			}
			return data
		}

		function animate(milliseconds) {

			// Calculate the time index array 
			let seconds = milliseconds / 1000;
			let time = seconds % max_time;
			// If the timer starts as bigger than the max time then set it to 0
			
			// debugger
			if (calculated_data.length != 0 && pivot_ship != undefined) {
				if(time < calculated_data[data_step_index].Time) {
					data_step_index = 0;
				}
				while(time > calculated_data[data_step_index].Time) {
					data_step_index += 1;
				}
				let delta = (calculated_data[data_step_index].Time - time)/delta_time;
				let interpolated_data = interpolate_csv(calculated_data[data_step_index], calculated_data[data_step_index - 1], delta);
				// pivot_ship.rotation.x += 0.01;

				// Pivot ship and spar buoy
				const data_cat = interpolated_data["Catamaran"];
				const data_spar = interpolated_data["Spar"];
				const deg_to_rad = Math.PI/180;
				pivot_ship.position.set(data_cat["YGtranslationTotalmotion"],
									-data_cat["XGtranslationTotalmotion"], 
									data_cat["ZGtranslationTotalmotion"]);
				pivot_buoy.position.set(data_spar["YGtranslationTotalmotion"], 
									data_spar["XGtranslationTotalmotion"], 
									data_spar["ZGtranslationTotalmotion"]);
				pivot_ship.rotation.set(data_cat["YLrotationTotalmotion"] * deg_to_rad, 
									data_cat["XLrotationTotalmotion"] * deg_to_rad, 
									data_cat["ZGrotationTotalmotion"] * deg_to_rad);
				pivot_buoy.rotation.set(data_spar["YLrotationTotalmotion"] * deg_to_rad, 
									data_spar["XLrotationTotalmotion"] * deg_to_rad, 
									data_spar["ZGrotationTotalmotion"] * deg_to_rad);
			}
			
			ocean.water.material.uniforms.time.value += 1 / 60;
			// ocean.water.render();
			// debugger

			renderer.render(scene, camera);
			requestAnimationFrame(animate);

			// Apply the function RayCaster
			// intersected = renderRayCaster(mouse, camera, zUpCont, intersected);

			// Apply the click information function
			// if (intersected.name === undefined) {
			// 	document.body.style.cursor = "default";
			// 	document.getElementById("SimulationWindow").onclick = false;
			// } else {
			// 	clickedInformation(tooltipElement, intersected);
			// }

			// In case the element was not clicked the toolTip Function will be triggered
			// if (!tooltipElement.displayingPropTable) {
			// 	toolTip(tooltipElement, intersected);
			// }
		}

	</script>
</body>

</html>
