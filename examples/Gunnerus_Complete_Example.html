<html>
	<head>
		<title>Ship in Ocean</title>
		<script src="../build/vessel.js"></script>

		<script src="libs/three_r118.js"></script>
		<script src="libs/STLLoader.js"></script>
		<script src="libs/GLTFLoader.js"></script>

		<script src="snippets/Ship3D_v2.js"></script>

		<!-- Upgrading to WaterShader2.js will remove the dependency
	on Mirror.js as well as open up possibilities for visualizing approximate water flows around vessels. -->
		<!-- <script src="libs/Mirror.js"></script>-->
		<!-- <script src="libs/WaterShader.js"></script> -->
		<script src="libs/Water.js"></script>

		<script src="libs/OrbitControls.js"></script>
		<script src="libs/dat.gui.min.js"></script>
		<script src="libs/skybox_from_examples_r118.js"></script>
		<script src="libs/browse_files_Elias_Hasle.js"></script>

		<script src="snippets/Patch_interpolation.js"></script>
		<script src="snippets/renderRayCaster.js"></script>
		<!--<script src="Moving_bodies_Elias_Hasle.js"></script>-->
		<script src="snippets/Playback.js"></script>
		<!-- <script src="snippets/Configurable_ocean.js"></script> -->
		<script src="snippets/Configurable_ocean2.js"></script>
		<!--<script src="keyboard_arrow_input_Elias_Hasle.js"></script>-->
	</head>

	<style>
		#tooltip {
			/* visibility: hidden; */
			position: absolute;
			font-family: Helvetica;
			display: block;
			background-color: black;
			color: #fff;
			text-align: center;
			padding: 5px 10px;
			border-radius: 6px;
			z-index: 101;
		}
	</style>

	<body>
		<div id="tooltip"></div>

		<script>
			"use strict"

			//Globals
			var renderer, camera, controls, gui, stats
			var scene, zUpCont, playback, bodies, ocean, ship3D, shipGLTF
			var scale, modelStyle

			// Global variables for raycaster control
			var intersected
			var tooltipElement = document.getElementById("tooltip")

			;(function main() {
				//Renderer setup
				//document.body.style = "overflow: hidden;";
				document.body.style.overflow = "hidden"
				var container = document.createElement("div")
				//container.style = "position: absolute; top: 0; left: 0;"
				Object.assign(container.style, {
					position: "absolute",
					top: 0,
					left: 0,
					width: "100vw",
					height: "100vh",
				})
				document.body.appendChild(container)
				renderer = new THREE.WebGLRenderer({ antialias: true })
				//renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0xa9cce3)
				container.appendChild(renderer.domElement)

				playback = new Playback({ parentGUI: gui })

				//Scene setup:
				scene = new THREE.Scene()
				let sun = new THREE.DirectionalLight(0xffffff, 2)
				sun.position.set(-512, 246, 128)
				scene.add(sun)

				//Ocean size
				let oSize = 2048

				//Use Z up from now on:
				THREE.Object3D.DefaultUp.set(0, 0, 1)
				zUpCont = new THREE.Group()
				// This rotation must be deleted in order to garantee the real coordinate
				// zUpCont.rotation.x = -0.5 * Math.PI;
				scene.add(zUpCont)

				var skybox = new Skybox(oSize)
				skybox.name = "Skybox"
				scene.add(skybox)

				//Camera setup
				camera = new THREE.PerspectiveCamera(26, window.innerWidth / window.innerHeight, 1, 1000000)

				let onResize = function () {
					let w = container.clientWidth
					let h = container.clientHeight
					renderer.setSize(w, h)
					camera.aspect = w / h
					camera.updateProjectionMatrix()
				}

				camera.up.set(0, 1, 0)

				window.addEventListener("resize", onResize, false)
				onResize()
				camera.position.set(oSize * 0.03, oSize * 0.03, oSize * 0.03)
				camera.lookAt(zUpCont.position)
				// zUpCont.add(camera)
				// scene.add(camera)

				controls = new THREE.OrbitControls(camera, renderer.domElement)
				//controls.minDistance = 0;
				// controls.maxDistance = 1.25 * oSize;
				controls.enablePan = false
				// controls.maxPolarAngle = 0.5 * Math.PI - 0.1;
				// controls.minPolarAngle = 0.1;

				// zUpCont.add(new THREE.AxesHelper(1000))
				zUpCont.add(new THREE.HemisphereLight(0xccccff, 0x666688, 1))

				ocean = new Ocean({
					parentGUI: gui,
					sunDir: sun.position.clone().normalize(),
					size: oSize,
					segments: 127,
				})

				// playback.add(ocean)
				ocean.name = "Ocean"
				scene.add(ocean)
				scene.rotation.x = -Math.PI / 2

				// scene.rotation.x = Math.PI;
				// scene.add(new THREE.AxesHelper(500));

				Vessel.loadShip(
					/*"specs/ship_specifications/PX121.json"*/
					/*"specs/ship_specifications/blockCase.json"*/
					/*"specs/ship_specifications/prismaticHull.json"*/
					// "specs/ship_specifications/trapezoidPrismHull.json",
					"specs/ship_specifications/Gunnerus.json",
					function (ship) {
						ship3D = new Ship3D(ship, {
							// stlPath: "specs/STL files",
							stlPath: "specs/STL files/Gunnerus",
							upperColor: 0x33aa33,
							lowerColor: 0xaa3333,
							hullOpacity: 1,
							deckOpacity: 1,
							objectOpacity: 1,
						})
						ship3D.name = "Ship3D"
						ship3D.show = "on"
						// zUpCont.add(ship3D)
					}
				)

				// import binary glTF file
				var boatPath = "specs/GLTF_files/Gunnerus.glb"
				var loaderGLTF = new THREE.GLTFLoader()
				loaderGLTF.load(boatPath, gltf => {
					shipGLTF = gltf.scene
					// mesh.material = new THREE.MeshLambertMaterial();
					shipGLTF.rotation.x = Math.PI / 2
					shipGLTF.rotation.y = -Math.PI / 2
					shipGLTF.position.set(-1, 0, 0)
					shipGLTF.name = "ModelGLTF"

					if (shipGLTF.material) {
						shipGLTF.material.side = THREE.DoubleSide
					}
					zUpCont.add(shipGLTF)
				})

				// Recursive function to find element and delete
				function toggleElement(element, name) {
					if (element.children.lenght == 0) {
						return
					}

					element.children.forEach(child => {
						if (child.group == name) {
							// Verify if it is visible trought the masks layers
							if (child.layers.mask) {
								child.layers.disable(0)
							} else {
								child.layers.enable(0)
							}
						}
						toggleElement(child, name)
					})
				}

				modelStyle = {
					model: "ModelGLTF",
					scene: "On",
					displayOutline: true,
				}

				// //GUI setup (comment out to remove gui)
				gui = new dat.GUI()

				scale = gui.addFolder("Visualization parameters")
				scale
					.add(modelStyle, "model", {
						Model: "ModelGLTF",
						Blocks: "Ship3D",
					})
					.onChange(newValue => {
						function verifyElement(element, index) {
							var otherName = {
								ModelGLTF: "Ship3D",
								Ship3D: "ModelGLTF",
							}

							if (element.name == otherName[newValue]) {
								zUpCont.remove(element)
							}
						}

						zUpCont.children.forEach(verifyElement)

						//
						switch (newValue) {
							case "ModelGLTF":
								zUpCont.add(shipGLTF)
								scale.domElement.hidden = true
								break

							case "Ship3D":
								zUpCont.add(ship3D)
								scale.domElement.hidden = false
								break

							default:
								break
						}
					})
					.name("View")
				scale
					.add(modelStyle, "scene", {
						On: "On",
						Off: "Off",
					})
					.onChange(newValue => {
						switch (newValue) {
							case "On":
								scene.getObjectByName("Skybox").visible = true
								scene.getObjectByName("Ocean").visible = true
								break

							case "Off":
								scene.getObjectByName("Skybox").visible = false
								scene.getObjectByName("Ocean").visible = false
								break

							default:
								break
						}
					})
					.name("Scenario")

				// scene.getObjectByName("Ocean").visible = false
				scale.open()

				scale = gui.addFolder("New")
				scale.domElement.hidden = true
				scale
					.add(modelStyle, "displayOutline")
					.onChange(newValue => {
						toggleElement(zUpCont, "Machinery")
					})
					.name("Machinery")

				scale
					.add(modelStyle, "displayOutline")
					.onChange(newValue => {
						toggleElement(zUpCont, "Tank")
					})
					.name("Tank")

				scale
					.add(modelStyle, "displayOutline")
					.onChange(newValue => {
						toggleElement(zUpCont, "Compartment")
					})
					.name("Compartment")

				scale
					.add(modelStyle, "displayOutline")
					.onChange(newValue => {
						toggleElement(zUpCont, "Deck")
					})
					.name("Deck")

				scale
					.add(modelStyle, "displayOutline")
					.onChange(newValue => {
						toggleElement(zUpCont, "Bulkheads")
					})
					.name("Bulkheads")

				scale.open()

				// playback.play()

				requestAnimationFrame(animate)
			})()

			var mouse = new THREE.Vector2()

			function onMouseMove(event) {
				// calculate mouse position in normalized device coordinates
				// (-1 to +1) for both components
				mouse.clientX = event.clientX
				mouse.clientY = event.clientY

				mouse.x = (event.clientX / window.innerWidth) * 2 - 1
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1
			}

			window.addEventListener("mousemove", onMouseMove, false)

			// Enabling setting Layers
			// scene.layers.enable(1)

			function toolTip(tooltip, intersected) {
				if (intersected.status) {
					// Inserting tooltip
					tooltip.style.visibility = "visible"
					tooltip.style.left = mouse.clientX + 20
					tooltip.style.top = mouse.clientY + 10
					tooltip.textContent = intersected.name
					zUpCont.remove(zUpCont.getObjectByName(intersected.name))
				} else {
					// Taking off tool tip
					tooltip.style.visibility = "hidden"
				}
			}

			function animate(millitime) {
				ocean.water.material.uniforms.time.value += 1 / 60

				// ocean.water.render();

				renderer.render(scene, camera)
				requestAnimationFrame(animate)

				intersected = renderRayCaster(mouse, camera, zUpCont, intersected)
				toolTip(tooltipElement, intersected)
			}
		</script>
	</body>
</html>
